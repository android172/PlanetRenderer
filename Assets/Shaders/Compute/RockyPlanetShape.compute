// includes
#include "./Includes/Noise/FractalNoise.cginc"
#include "./Includes/ShapeComputeUtil.cginc"
#include "./Includes/SmoothMinMax.cginc"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel lod_kernel
#pragma kernel compute_shape

// Vertex information
RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> out_vertices;
RWStructuredBuffer<float3> normals;
uint num_of_vertices;

// ============ LOD KERNEL ============

// Node decoding
uint undilate(uint x) {
    x = (x | (x >> 1u)) & 0x33333333;
    x = (x | (x >> 2u)) & 0x0f0f0f0f;
    x = (x | (x >> 4u)) & 0x00ff00ff;
    x = (x | (x >> 8u)) & 0x0000ffff;
    return x & 0x0000ffff;
}

void decode(in uint node_code, out uint level, out uint2 coords) {
    level = node_code & 0xf;
    coords.x = undilate((node_code >> 4u) & 0x05555555);
    coords.y = undilate((node_code >> 5u) & 0x05555555);
}

struct LodLayoutChanges {
  uint new_node_code;
  uint offset; // tile chunk number offset from face start
  int face_number; // face offset
};

static const float3 node_centers[6] = {
  float3(0.0, 0.0, 1.0),  // Front
  float3(0.0, 0.0, -1.0), // Back
  float3(0.0, 1.0, 0.0),  // Top
  float3(0.0, -1.0, 0.0), // Bottom
  float3(1.0, 0.0, 0.0),  // Right
  float3(-1.0, 0.0, 0.0)  // Left
};

// Lod layout - specifies which node (uint code) each chunk in the position buffer belongs to
RWStructuredBuffer<uint> lod_layout;

// Lod changes
StructuredBuffer<LodLayoutChanges> lod_layout_changes;

int MAX_NUM_NODES; // 3 * max_level + 1

float sphere_radius;
uint index_count_per_instance;
uint num_changes;

float3 calculate_sphere_position(uint level, uint2 coords, int vertex_id, float3 face_center);

[numthreads(256,1,1)]
void lod_kernel(uint id : SV_DispatchThreadID) {
  if(id >= num_changes * num_of_vertices)
    return;

  int change_id = id / num_of_vertices;
  int vertex_id = id % num_of_vertices;

  LodLayoutChanges change = lod_layout_changes[change_id];

  // Update lod layout buffer
  uint tile_index = change.face_number * MAX_NUM_NODES + change.offset;
  lod_layout[tile_index] = change.new_node_code;

  // Recalculate new vertices
  if(change.new_node_code != 0) {
    // Decode node 
    uint2 coords;
    uint level;
    decode(change.new_node_code, level, coords);
    
    uint vertex_buffer_index = change.face_number * MAX_NUM_NODES * num_of_vertices + change.offset * num_of_vertices + vertex_id;

    // calculate position on sphere
    float3 initial_position = calculate_sphere_position(level, coords, vertex_id, node_centers[change.face_number]);
    vertices[vertex_buffer_index] = initial_position;

    // apply noise
    out_vertices[vertex_buffer_index] = apply_noise(initial_position);

    // Compute surface normal, diff_angle is the average distance between points
    float diff_angle = 1.0 / sqrt(pow(4, level) * num_of_vertices);
    normals[vertex_buffer_index] = compute_normal(vertices[vertex_buffer_index], out_vertices[vertex_buffer_index], diff_angle);
  }
}

float3 map_point_to_sphere(float3 p) {
    float x_sq = p.x * p.x;
    float y_sq = p.y * p.y;
    float z_sq = p.z * p.z;

    p.x *= sqrt(1.0 - y_sq / 2.0 - z_sq / 2.0 + y_sq * z_sq / 3.0);
    p.y *= sqrt(1.0 - z_sq / 2.0 - x_sq / 2.0 + z_sq * x_sq / 3.0);
    p.z *= sqrt(1.0 - x_sq / 2.0 - y_sq / 2.0 + x_sq * y_sq / 3.0);
    
    return p;
}

float3 calculate_sphere_position(uint level, uint2 coords, int vertex_id, float3 face_center) {
  // Get vertex position on -1 to 1 grid
  uint resolution = sqrt(num_of_vertices);
  float two_to_level = 1 << level;
  uint tile_x = vertex_id % resolution;
  uint tile_y = vertex_id / resolution;
  float vertex_x = -1.0 + (4*coords.x + 1 + (2 * tile_x) / resolution) / two_to_level;
  float vertex_y = -1.0 + (4*coords.y + 1 + (2 * tile_y) / resolution) / two_to_level;

  // Get center on unit cube
  float3 child_center_unit_cube;
  if(face_center.x != 0.0f) {
      // Right or left face
      child_center_unit_cube = float3(face_center.x, vertex_x, vertex_y);
  } else if(face_center.y != 0.0f) {
      // Top or bottom face
      child_center_unit_cube = float3(vertex_x, face_center.y, vertex_y);
  } else if(face_center.z != 0.0f) {
      // Front or back face
      child_center_unit_cube = float3(vertex_x, vertex_y, face_center.z);
  }

  // map to sphere
  return normalize(map_point_to_sphere(child_center_unit_cube)) * sphere_radius;
}

// ============ NOISE KERNEL ============

// Settings
float4 shape_limits;
float4 old_shape_limits;
// Shape Settings
int4 enabled[2];
float4 noise_settings_continent_shape[3];
float4 noise_settings_both[3];
float4 noise_settings_mountains[3];
float4 noise_settings_ocean_mountains[3];
float4 noise_settings_flatness[3];
float4 noise_settings_crater[4];
// Surface specific
float continent_base;
float ocean_depth;
float flatness_ratio;

bool vertex_is_visible(float3 vertex);
bool vertex_was_visible(float3 vertex);

// Kernels
[numthreads(256, 1, 1)] 
void compute_shape(uint id : SV_DispatchThreadID) {
  if (id >= num_of_vertices)
    return;

  // Check for visibility
  if (!vertex_is_visible(vertices[id])) {
    out_vertices[id] = float3(0, 0, 0);
    return;
  }
  if (vertex_was_visible(vertices[id]))
    return;

  // Compute new position
  out_vertices[id] = apply_noise(vertices[id]);

  // Compute surface normal
  float diff_angle = 1.0 / sqrt(num_of_vertices / 6.0);
  normals[id] = compute_normal(vertices[id], out_vertices[id], diff_angle);
}

bool vertex_is_visible(float3 vertex) {
  float3 camera_dir = shape_limits.xyz;
  float max_render_angle = shape_limits.w;
  return dot(vertex, camera_dir) >= max_render_angle;
}

bool vertex_was_visible(float3 vertex) {
  float3 camera_dir = old_shape_limits.xyz;
  float max_render_angle = old_shape_limits.w;
  return dot(vertex, camera_dir) >= max_render_angle;
}

float3 apply_noise(float3 position) {
  // enables ==for readability==
  int continents_enabled = enabled[0].x;
  int general_noise_enabled = enabled[0].y;
  int mountains_enabled = enabled[0].z;
  int ocean_mountains_enabled = enabled[0].w;
  int flatness_enabled = enabled[1].x;
  int craters_enabled = enabled[1].y;

  // continent / ocean mask //
  float continent_height = continent_base - ocean_depth;
  float c_base = continents_enabled *
                 (clamp(fractal_noise(position, noise_settings_continent_shape),
                        ocean_depth, continent_base) -
                  continent_base);
  float continent_mask = (continent_height == 0)
                             ? 1
                             : (c_base + continent_height) / continent_height;
  float ocean_mask = 1 - continent_mask;

  // flatness //
  float flatness =
      (flatness_enabled)
          ? (clamp(fractal_noise(position, noise_settings_flatness),
                   flatness_ratio, flatness_ratio + 0.1) -
             flatness_ratio) /
                0.1
          : 1;

  // continent //
  // mountains
  float ridge_1 = mountains_enabled *
                  ridge_noise(position, noise_settings_mountains) *
                  continent_mask * flatness * 0.1;
  // crater
  float crater = craters_enabled * //
                 crater_noise(position, noise_settings_crater) * continent_mask;

  // ocean //
  // underwater mountains
  float ridge_2 = ocean_mountains_enabled * //
                  ridge_noise_2(position, noise_settings_ocean_mountains) *
                  ocean_mask * flatness * 0.1;

  // both //
  // bumps
  float bumbs = general_noise_enabled * //
                fractal_noise(position, noise_settings_both);

  // Final height
  float height =
      1 + (c_base + smax(ridge_1, ridge_2, 8.0) + crater + bumbs) / 4;

  return position * height;
}
